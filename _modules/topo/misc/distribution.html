
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>topo.misc.distribution &mdash; The Topographica Neural Map Simulator</title>
    
    <link rel="stylesheet" href="../../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/topo.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.98',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/topo.js"></script>
    <link rel="top" title="The Topographica Neural Map Simulator" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>


<li><ul class="parents">



          <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for topo.misc.distribution</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Distribution class</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># To do:</span>
<span class="c">#</span>
<span class="c"># - wrap bins for cyclic histograms</span>
<span class="c"># - check use of float() in count_mag() etc</span>
<span class="c"># - clarify comment about negative selectivity</span>
<span class="c">#</span>
<span class="c"># - function to return value in a range (like a real histogram)</span>
<span class="c"># - cache values</span>
<span class="c"># - assumes cyclic axes start at 0: include a shift based on range</span>
<span class="c">#</span>
<span class="c"># - is there a way to make this work for arrays without mentioning</span>
<span class="c">#   &quot;array&quot; anywhere in here?</span>
<span class="c"># - should this be two classes: one for the core (which would be</span>
<span class="c">#   small though) and another for statistics?</span>



<span class="c"># The basic functions do not have any dependencies, but these imports</span>
<span class="c"># are needed for some of the statistical functions (e.g. vector sum).</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">param</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>

<span class="n">unavailable_scipy_optimize</span>  <span class="o">=</span> <span class="bp">False</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy</span>            <span class="kn">import</span> <span class="n">optimize</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">()</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;scipy.optimize not available, dummy von Mises fit&quot;</span><span class="p">)</span>
    <span class="n">unavailable_scipy_optimize</span>  <span class="o">=</span> <span class="bp">True</span>

<span class="kn">from</span> <span class="nn">numpy</span>            <span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">log</span>
<span class="kn">from</span> <span class="nn">numpy.oldnumeric</span> <span class="kn">import</span> <span class="n">innerproduct</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">argmax</span>

<span class="kn">from</span> <span class="nn">topo.base.arrayutil</span> <span class="kn">import</span> <span class="n">arg</span><span class="p">,</span> <span class="n">wrap</span>

<div class="viewcode-block" id="Distribution"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution">[docs]</a><span class="k">class</span> <span class="nc">Distribution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Holds a distribution of the values f(x) associated with a variable x.</span>

<span class="sd">    A Distribution is a histogram-like object that is a dictionary of</span>
<span class="sd">    samples.  Each sample is an x:f(x) pair, where x is called the bin</span>
<span class="sd">    and f(x) is called the value(). Each bin&#39;s value is typically</span>
<span class="sd">    maintained as the sum of all the values that have been placed into</span>
<span class="sd">    it.</span>

<span class="sd">    The bin axis is continuous, and can represent a continuous</span>
<span class="sd">    quantity without discretization.  Alternatively, this class can be</span>
<span class="sd">    used as a traditional histogram by either discretizing the bin</span>
<span class="sd">    number before adding each sample, or by binning the values in the</span>
<span class="sd">    final Distribution.</span>

<span class="sd">    Distributions are bounded by the specified axis_bounds, and can</span>
<span class="sd">    either be cyclic (like directions or hues) or non-cyclic.  For</span>
<span class="sd">    cyclic distributions, samples provided outside the axis_bounds</span>
<span class="sd">    will be wrapped back into the bound range, as is appropriate for</span>
<span class="sd">    quantities like directions.  For non-cyclic distributions,</span>
<span class="sd">    providing samples outside the axis_bounds will result in a</span>
<span class="sd">    ValueError.</span>

<span class="sd">    In addition to the values, can also return the counts, i.e., the</span>
<span class="sd">    number of times that a sample has been added with the given bin.</span>

<span class="sd">    Not all instances of this class will be a true distribution in the</span>
<span class="sd">    mathematical sense; e.g. the values will have to be normalized</span>
<span class="sd">    before they can be considered a probability distribution.</span>

<span class="sd">    If keep_peak=True, the value stored in each bin will be the</span>
<span class="sd">    maximum of all values ever added, instead of the sum.  The</span>
<span class="sd">    distribution will thus be a record of the maximum value</span>
<span class="sd">    seen at each bin, also known as an envelope.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Holds the number of times that undefined values have been</span>
    <span class="c"># returned from calculations for any instance of this class,</span>
    <span class="c"># e.g. calls to vector_direction() or vector_selectivity() when no</span>
    <span class="c"># value is non-zero.  Useful for warning users when the values are</span>
    <span class="c"># not meaningful.</span>
    <span class="n">undefined_vals</span>  <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span> <span class="n">cyclic</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">keep_peak</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c"># total_count and total_value hold the total number and sum</span>
        <span class="c"># (respectively) of values that have ever been provided for</span>
        <span class="c"># each bin.  For a simple distribution these will be the same as</span>
        <span class="c"># sum_counts() and sum_values().</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_value</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">axis_bounds</span> <span class="o">=</span> <span class="n">axis_bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis_range</span> <span class="o">=</span> <span class="n">axis_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">axis_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span> <span class="o">=</span> <span class="n">cyclic</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep_peak</span> <span class="o">=</span> <span class="n">keep_peak</span>



    <span class="c">### JABHACKALERT!  The semantics of this operation are incorrect, because</span>
    <span class="c">### an expression like x+y should not modify x, while this does.  It could</span>
    <span class="c">### be renamed __iadd__, to implement += (which has the correct semantics),</span>
    <span class="c">### but it&#39;s not yet clear how to do that.</span>
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allows add() method to be used via the &#39;+&#39; operator; i.e.,</span>
<span class="sd">        Distribution + dictionary does Distribution.add(dictionary).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">None</span>


<div class="viewcode-block" id="Distribution.get_value"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.get_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value of the specified bin.</span>

<span class="sd">        (Return None if there is no such bin.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">bin</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Distribution.get_count"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.get_count">[docs]</a>    <span class="k">def</span> <span class="nf">get_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the count from the specified bin.</span>

<span class="sd">        (Return None if there is no such bin.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">bin</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Distribution.values"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of values.</span>

<span class="sd">        Various statistics can then be calculated if desired:</span>

<span class="sd">          sum(vals)  (total of all values)</span>
<span class="sd">          max(vals)  (highest value in any bin)</span>

<span class="sd">        Note that the bin-order of values returned does not necessarily</span>
<span class="sd">        match that returned by counts().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Distribution.counts"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.counts">[docs]</a>    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of values.</span>

<span class="sd">        Various statistics can then be calculated if desired:</span>

<span class="sd">          sum(counts)  (total of all counts)</span>
<span class="sd">          max(counts)  (highest count in any bin)</span>

<span class="sd">        Note that the bin-order of values returned does not necessarily</span>
<span class="sd">        match that returned by values().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Distribution.bins"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.bins">[docs]</a>    <span class="k">def</span> <span class="nf">bins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of bins that have been populated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="Distribution.add"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a set of new data in the form of a dictionary of (bin,</span>
<span class="sd">        value) pairs.  If the bin already exists, the value is added</span>
<span class="sd">        to the current value.  If the bin doesn&#39;t exist, one is created</span>
<span class="sd">        with that value.</span>

<span class="sd">        Bin numbers outside axis_bounds are allowed for cyclic=True,</span>
<span class="sd">        but otherwise a ValueError is raised.</span>

<span class="sd">        If keep_peak=True, the value of the bin is the maximum of the</span>
<span class="sd">        current value and the supplied value.  That is, the bin stores</span>
<span class="sd">        the peak value seen so far.  Note that each call will increase</span>
<span class="sd">        the total_value and total_count (and thus decrease the</span>
<span class="sd">        value_mag() and count_mag()) even if the value doesn&#39;t happen</span>
<span class="sd">        to be the maximum seen so far, since each data point still</span>
<span class="sd">        helps improve the sampling and thus the confidence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="n">new_data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cyclic</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nb">bin</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axis_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Bin outside bounds.&quot;</span><span class="p">)</span>
            <span class="c"># CEBALERT: Neet to support wrapping of bin values</span>
            <span class="c"># else:  new_bin = wrap(self.axis_bounds[0], self.axis_bounds[1], bin)</span>
            <span class="n">new_bin</span> <span class="o">=</span> <span class="nb">bin</span>

            <span class="k">if</span> <span class="n">new_bin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">new_bin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">[</span><span class="n">new_bin</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="n">new_value</span> <span class="o">=</span> <span class="n">new_data</span><span class="p">[</span><span class="nb">bin</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_value</span> <span class="o">+=</span> <span class="n">new_value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="p">[</span><span class="n">new_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keep_peak</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">new_value</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">new_bin</span><span class="p">]:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">new_bin</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">new_bin</span><span class="p">]</span> <span class="o">+=</span> <span class="n">new_value</span>

</div>
<div class="viewcode-block" id="Distribution.sub_distr"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.sub_distr">[docs]</a>    <span class="k">def</span> <span class="nf">sub_distr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distr</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract the given distribution from the current one.</span>
<span class="sd">        Only existing bins are modified, new bins in the given</span>
<span class="sd">        distribution are discarded without raising errors.</span>

<span class="sd">        Note that total_value and total_count are not affected, and</span>
<span class="sd">        keep_peak is ignored, therefore analysis relying on these</span>
<span class="sd">        values should not call this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">distr</span><span class="o">.</span><span class="n">bins</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bins</span><span class="p">():</span>
                <span class="n">v</span>   <span class="o">=</span> <span class="n">distr</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>   <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span> <span class="n">b</span> <span class="p">]</span> <span class="o">-=</span> <span class="n">v</span>

</div>
<div class="viewcode-block" id="Distribution.max_value_bin"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.max_value_bin">[docs]</a>    <span class="k">def</span> <span class="nf">max_value_bin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the bin with the largest value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
</div>
<div class="viewcode-block" id="Distribution.weighted_sum"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.weighted_sum">[docs]</a>    <span class="k">def</span> <span class="nf">weighted_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the sum of each value times its bin.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">innerproduct</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

</div>
<div class="viewcode-block" id="Distribution.value_mag"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.value_mag">[docs]</a>    <span class="k">def</span> <span class="nf">value_mag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the value of a single bin as a proportion of total_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">bin</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_value</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="Distribution.count_mag"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Distribution.count_mag">[docs]</a>    <span class="k">def</span> <span class="nf">count_mag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the count of a single bin as a proportion of total_count.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">bin</span><span class="p">)),</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">total_count</span><span class="p">))</span>
        <span class="c"># use of float()</span>

</div>
    <span class="k">def</span> <span class="nf">_bins_to_radians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">bin</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a bin number to a direction in radians.</span>

<span class="sd">        Works for NumPy arrays of bin numbers, returning</span>
<span class="sd">        an array of directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="nb">bin</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_range</span>


    <span class="k">def</span> <span class="nf">_radians_to_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">direction</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a direction in radians into a bin number.</span>

<span class="sd">        Works for NumPy arrays of direction, returning</span>
<span class="sd">        an array of bin numbers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">direction</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">axis_range</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_safe_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">numerator</span><span class="p">,</span><span class="n">denominator</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Division routine that avoids division-by-zero errors</span>
<span class="sd">        (returning zero in such cases) but keeps track of them</span>
<span class="sd">        for undefined_values().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">denominator</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">undefined_vals</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">numerator</span><span class="o">/</span><span class="n">denominator</span>

</div>
<div class="viewcode-block" id="Pref"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.Pref">[docs]</a><span class="k">class</span> <span class="nc">Pref</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class simply collects named arguments into a dictionary</span>

<span class="sd">    the main purpose is to make pretty readable the output of DistributionStatisticFn</span>
<span class="sd">    functions.</span>
<span class="sd">    In addition, trap missing keys</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span> <span class="p">):</span>
        <span class="nb">dict</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>


</div>
<div class="viewcode-block" id="DistributionStatisticFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DistributionStatisticFn">[docs]</a><span class="k">class</span> <span class="nc">DistributionStatisticFn</span><span class="p">(</span> <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for various functions performing statistics on a distribution</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">value_scale</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">NumericTuple</span><span class="p">(</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">            Scaling of the resulting value of the distribution statistics,</span>
<span class="s">            typically the preference of a unit to feature values. The tuple</span>
<span class="s">            specifies (offset, multiplier) of the output scaling&quot;&quot;&quot;</span> <span class="p">)</span>

<span class="c"># APNOTE: previously selectivity_scale[ 1 ] used to be 17, a value suitable</span>
<span class="c"># for combining preference and selectivity in HSV plots. Users wishing to keep</span>
<span class="c"># this value should now set it when creating SheetViews, in commands like that</span>
<span class="c"># in command/analysis.py</span>
    <span class="n">selectivity_scale</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">NumericTuple</span><span class="p">(</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">            Scaling of the resulting measure of the distribution peakedness,</span>
<span class="s">            typically the selectivity of a unit to its preferred feature value.</span>
<span class="s">            The tuple specifies (offset, multiplier) of the output scaling&quot;&quot;&quot;</span> <span class="p">)</span>

    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the distribution statistic function; must be implemented by subclasses.</span>

<span class="sd">        Subclasses sould be called with a Distribution as argument, return will be a</span>
<span class="sd">        dictionary, with Pref objects as values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

</div>
<div class="viewcode-block" id="DescriptiveStatisticFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveStatisticFn">[docs]</a><span class="k">class</span> <span class="nc">DescriptiveStatisticFn</span><span class="p">(</span> <span class="n">DistributionStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class for basic descriptive statistics</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DescriptiveStatisticFn.vector_sum"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveStatisticFn.vector_sum">[docs]</a>    <span class="k">def</span> <span class="nf">vector_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the vector sum of the distribution as a tuple (magnitude, avgbinnum).</span>

<span class="sd">        Each bin contributes a vector of length equal to its value, at</span>
<span class="sd">        a direction corresponding to the bin number.  Specifically,</span>
<span class="sd">        the total bin number range is mapped into a direction range</span>
<span class="sd">        [0,2pi].</span>

<span class="sd">        For a cyclic distribution, the avgbinnum will be a continuous</span>
<span class="sd">        measure analogous to the max_value_bin() of the distribution.</span>
<span class="sd">        But this quantity has more precision than max_value_bin()</span>
<span class="sd">        because it is computed from the entire distribution instead of</span>
<span class="sd">        just the peak bin.  However, it is likely to be useful only</span>
<span class="sd">        for uniform or very dense sampling; with sparse, non-uniform</span>
<span class="sd">        sampling the estimates will be biased significantly by the</span>
<span class="sd">        particular samples chosen.</span>

<span class="sd">        The avgbinnum is not meaningful when the magnitude is 0,</span>
<span class="sd">        because a zero-length vector has no direction.  To find out</span>
<span class="sd">        whether such cases occurred, you can compare the value of</span>
<span class="sd">        undefined_vals before and after a series of calls to this</span>
<span class="sd">        function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># vectors are represented in polar form as complex numbers</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">r</span>   <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_bins_to_radians</span><span class="p">(</span><span class="n">array</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="p">))</span>
        <span class="n">v_sum</span> <span class="o">=</span> <span class="n">innerproduct</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">exp</span><span class="p">(</span><span class="n">theta</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span>

        <span class="n">magnitude</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">v_sum</span><span class="p">)</span>
        <span class="n">direction</span> <span class="o">=</span> <span class="n">arg</span><span class="p">(</span><span class="n">v_sum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">v_sum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">undefined_vals</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">direction_radians</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_radians_to_bins</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>

        <span class="c"># wrap the direction because arctan2 returns principal values</span>
        <span class="n">wrapped_direction</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">axis_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="o">.</span><span class="n">axis_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">direction_radians</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">wrapped_direction</span><span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_weighted_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the weighted_sum divided by the sum of the values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">weighted_sum</span><span class="p">(),</span><span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>


<div class="viewcode-block" id="DescriptiveStatisticFn.selectivity"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveStatisticFn.selectivity">[docs]</a>    <span class="k">def</span> <span class="nf">selectivity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a measure of the peakedness of the distribution.  The</span>
<span class="sd">        calculation differs depending on whether this is a cyclic</span>
<span class="sd">        variable.  For a cyclic variable, returns the magnitude of the</span>
<span class="sd">        vector_sum() divided by the sum_value() (see</span>
<span class="sd">        _vector_selectivity for more details).  For a non-cyclic</span>
<span class="sd">        variable, returns the max_value_bin()) as a proportion of the</span>
<span class="sd">        sum_value() (see _relative_selectivity for more details).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">cyclic</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vector_selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relative_selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>


    <span class="c"># CEBHACKALERT: the definition of selectivity for non-cyclic</span>
    <span class="c"># quantities probably needs some more thought.</span>
    <span class="c"># Additionally, this fails the test in testfeaturemap</span>
    <span class="c"># (see the comment there).</span></div>
    <span class="k">def</span> <span class="nf">_relative_selectivity</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return max_value_bin()) as a proportion of the sum_value().</span>

<span class="sd">        This quantity is a measure of how strongly the distribution is</span>
<span class="sd">        biased towards the max_value_bin().  For a smooth,</span>
<span class="sd">        single-lobed distribution with an inclusive, non-cyclic range,</span>
<span class="sd">        this quantity is an analog to vector_selectivity.  To be a</span>
<span class="sd">        precise analog for arbitrary distributions, it would need to</span>
<span class="sd">        compute some measure of the selectivity that works like the</span>
<span class="sd">        weighted_average() instead of the max_value_bin().  The result</span>
<span class="sd">        is scaled such that if all bins are identical, the selectivity</span>
<span class="sd">        is 0.0, and if all bins but one are zero, the selectivity is</span>
<span class="sd">        1.0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># A single bin is considered fully selective (but could also</span>
        <span class="c"># arguably be considered fully unselective)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.0</span>

        <span class="n">proportion</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span> <span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span>
                                        <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="p">)</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="n">scaled</span> <span class="o">=</span> <span class="p">(</span><span class="n">proportion</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span>

        <span class="c"># negative scaled is possible</span>
        <span class="c"># e.g. 2 bins, with values that sum to less than 0.5</span>
        <span class="c"># this probably isn&#39;t what should be done in those cases</span>
        <span class="k">if</span> <span class="n">scaled</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scaled</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>


    <span class="k">def</span> <span class="nf">_vector_selectivity</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the magnitude of the vector_sum() divided by the sum_value().</span>

<span class="sd">        This quantity is a vector-based measure of the peakedness of</span>
<span class="sd">        the distribution.  If only a single bin has a non-zero value(),</span>
<span class="sd">        the selectivity will be 1.0, and if all bins have the same</span>
<span class="sd">        value() then the selectivity will be 0.0.  Other distributions</span>
<span class="sd">        will result in intermediate values.</span>

<span class="sd">        For a distribution with a sum_value() of zero (i.e. all bins</span>
<span class="sd">        empty), the selectivity is undefined.  Assuming that one will</span>
<span class="sd">        usually be looking for high selectivity, we return zero in such</span>
<span class="sd">        a case so that high selectivity will not mistakenly be claimed.</span>
<span class="sd">        To find out whether such cases occurred, you can compare the</span>
<span class="sd">        value of undefined_values() before and after a series of</span>
<span class="sd">        calls to this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vector_sum</span><span class="p">(</span> <span class="n">d</span> <span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>


    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>


</div>
<div class="viewcode-block" id="DescriptiveBimodalStatisticFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveBimodalStatisticFn">[docs]</a><span class="k">class</span> <span class="nc">DescriptiveBimodalStatisticFn</span><span class="p">(</span> <span class="n">DescriptiveStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class for descriptive statistics of two-modes distributions</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DescriptiveBimodalStatisticFn.second_max_value_bin"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveBimodalStatisticFn.second_max_value_bin">[docs]</a>    <span class="k">def</span> <span class="nf">second_max_value_bin</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bin with the second largest value.</span>
<span class="sd">        If there is one bin only, return it. This is not a correct result,</span>
<span class="sd">        however it is practical for plotting compatibility, and it will not</span>
<span class="sd">        mistakenly be claimed as secondary maximum, by forcing its selectivity</span>
<span class="sd">        to 0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span> <span class="mi">0</span> <span class="p">]</span>

        <span class="n">k</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">v</span>       <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">m</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">m</span>

</div>
<div class="viewcode-block" id="DescriptiveBimodalStatisticFn.second_selectivity"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveBimodalStatisticFn.second_selectivity">[docs]</a>    <span class="k">def</span> <span class="nf">second_selectivity</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the selectivity of the second largest value in the distribution.</span>
<span class="sd">        If there is one bin only, the selectivity is 0, since there is no second</span>
<span class="sd">        peack at all, and this value is also used to discriminate the validity</span>
<span class="sd">        of second_max_value_bin()</span>
<span class="sd">        Selectivity is computed in two ways depending on whether the variable is</span>
<span class="sd">        a cyclic, as in selectivity()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">cyclic</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vector_second_selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relative_second_selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>

</div>
    <span class="k">def</span> <span class="nf">_relative_second_selectivity</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the value of the second maximum as a proportion of the sum_value()</span>
<span class="sd">        see _relative_selectivity() for further details</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">k</span>               <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">v</span>               <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">m</span>               <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>   <span class="o">=</span> <span class="n">v</span>

        <span class="n">proportion</span>      <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">offset</span>          <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
        <span class="n">scaled</span>          <span class="o">=</span> <span class="p">(</span><span class="n">proportion</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="n">offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span> <span class="n">scaled</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span>


    <span class="k">def</span> <span class="nf">_vector_second_selectivity</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the magnitude of the vector_sum() of all bins excluding the</span>
<span class="sd">        maximum one, divided by the sum_value().</span>
<span class="sd">        see _vector_selectivity() for further details</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">k</span>               <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">v</span>               <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">s</span>               <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">vector_sum</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>   <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span> <span class="n">s</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>


<div class="viewcode-block" id="DescriptiveBimodalStatisticFn.second_peak_bin"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveBimodalStatisticFn.second_peak_bin">[docs]</a>    <span class="k">def</span> <span class="nf">second_peak_bin</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the bin with the second peak in the distribution.</span>
<span class="sd">        Unlike second_max_value_bin(), it does not return a bin which is the</span>
<span class="sd">        second largest value, if laying on a wing of the first peak, the second</span>
<span class="sd">        peak is returned only if the distribution is truly multimodal. If it isn&#39;t,</span>
<span class="sd">        return the first peak (for compatibility with numpy array type, and</span>
<span class="sd">        plotting compatibility), however the correspondong selectivity will be</span>
<span class="sd">        forced to 0.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">l</span>   <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span> <span class="mi">0</span> <span class="p">]</span>

        <span class="n">ks</span>  <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">ks</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">ik0</span> <span class="o">=</span> <span class="n">ks</span><span class="o">.</span><span class="n">index</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span> <span class="n">argmax</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">k0</span>  <span class="o">=</span> <span class="n">ks</span><span class="p">[</span> <span class="n">ik0</span> <span class="p">]</span>
        <span class="n">v0</span>  <span class="o">=</span> <span class="n">h</span><span class="p">[</span> <span class="n">k0</span> <span class="p">]</span>

        <span class="n">v</span>   <span class="o">=</span> <span class="n">v0</span>
        <span class="n">k</span>   <span class="o">=</span> <span class="n">k0</span>
        <span class="n">ik</span>  <span class="o">=</span> <span class="n">ik0</span>
        <span class="k">while</span> <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">ik</span>  <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ik</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">ik</span>      <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">ik</span> <span class="o">==</span> <span class="n">ik0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k0</span>
            <span class="n">v</span>   <span class="o">=</span> <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span>
            <span class="n">k</span>   <span class="o">=</span> <span class="n">ks</span><span class="p">[</span> <span class="n">ik</span> <span class="p">]</span>
        <span class="n">ik1</span> <span class="o">=</span> <span class="n">ik</span>

        <span class="n">v</span>   <span class="o">=</span> <span class="n">v0</span>
        <span class="n">k</span>   <span class="o">=</span> <span class="n">k0</span>
        <span class="n">ik</span>  <span class="o">=</span> <span class="n">ik0</span>
        <span class="k">while</span> <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">:</span>
            <span class="n">ik</span>  <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ik</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ik</span>  <span class="o">=</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ik</span> <span class="o">==</span> <span class="n">ik0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">k0</span>
            <span class="n">v</span>   <span class="o">=</span> <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span>
            <span class="n">k</span>   <span class="o">=</span> <span class="n">ks</span><span class="p">[</span> <span class="n">ik</span> <span class="p">]</span>
        <span class="n">ik2</span> <span class="o">=</span> <span class="n">ik</span>

        <span class="k">if</span> <span class="n">ik1</span> <span class="o">==</span> <span class="n">ik2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ks</span><span class="p">[</span> <span class="n">ik1</span> <span class="p">]</span>

        <span class="n">ik</span>  <span class="o">=</span> <span class="n">ik1</span>
        <span class="n">m</span>   <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">ik</span> <span class="o">!=</span> <span class="n">ik2</span><span class="p">:</span>
            <span class="n">k</span>   <span class="o">=</span> <span class="n">ks</span><span class="p">[</span> <span class="n">ik</span> <span class="p">]</span>
            <span class="k">if</span> <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">m</span>   <span class="o">=</span> <span class="n">h</span><span class="p">[</span> <span class="n">k</span> <span class="p">]</span>
                <span class="n">im</span>  <span class="o">=</span> <span class="n">ik</span>
            <span class="n">ik</span>  <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ik</span> <span class="o">&gt;=</span> <span class="n">l</span><span class="p">:</span>
                <span class="n">ik</span>  <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="n">ks</span><span class="p">[</span> <span class="n">im</span> <span class="p">]</span>

</div>
<div class="viewcode-block" id="DescriptiveBimodalStatisticFn.second_peak_selectivity"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveBimodalStatisticFn.second_peak_selectivity">[docs]</a>    <span class="k">def</span> <span class="nf">second_peak_selectivity</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the selectivity of the second peak in the distribution.</span>

<span class="sd">        If the distribution has only one peak, return 0.0, and this value is</span>
<span class="sd">        also usefl to discriminate the validity of second_peak_bin()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">p1</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">p2</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_peak_bin</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>

        <span class="n">m</span>           <span class="o">=</span> <span class="n">h</span><span class="p">[</span> <span class="n">p2</span> <span class="p">]</span>
        <span class="n">proportion</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">offset</span>      <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span>
        <span class="n">scaled</span>      <span class="o">=</span> <span class="p">(</span><span class="n">proportion</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span> <span class="n">scaled</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="DescriptiveBimodalStatisticFn.second_peak"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DescriptiveBimodalStatisticFn.second_peak">[docs]</a>    <span class="k">def</span> <span class="nf">second_peak</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return preference and selectivity of the second peak in the distribution.</span>

<span class="sd">        It is just the combination of second_peak_bin() and</span>
<span class="sd">        second_peak_selectivity(), with the advantage of avoiding a duplicate</span>
<span class="sd">        call of second_peak_bin(), if the user is interested in both preference</span>
<span class="sd">        and selectivity, as often is the case.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">h</span>   <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span> <span class="mi">0</span> <span class="p">],</span> <span class="mf">0.0</span> <span class="p">)</span>

        <span class="n">p1</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">p2</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_peak_bin</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="o">==</span> <span class="n">p2</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span> <span class="n">p1</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span>

        <span class="n">m</span>           <span class="o">=</span> <span class="n">h</span><span class="p">[</span> <span class="n">p2</span> <span class="p">]</span>
        <span class="n">proportion</span>  <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">_safe_divide</span><span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">h</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">offset</span>      <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span> <span class="n">h</span> <span class="p">)</span>
        <span class="n">scaled</span>      <span class="o">=</span> <span class="p">(</span><span class="n">proportion</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span> <span class="n">p2</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span> <span class="n">scaled</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">)</span>

</div>
    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>


</div>
<div class="viewcode-block" id="DSF_MaxValue"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DSF_MaxValue">[docs]</a><span class="k">class</span> <span class="nc">DSF_MaxValue</span><span class="p">(</span> <span class="n">DescriptiveStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the peak value of the given distribution</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="n">p</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span> <span class="p">)</span> <span class="p">}</span>


</div>
<div class="viewcode-block" id="DSF_WeightedAverage"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DSF_WeightedAverage">[docs]</a><span class="k">class</span> <span class="nc">DSF_WeightedAverage</span><span class="p">(</span> <span class="n">DescriptiveStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the main mode of the given distribution</span>

<span class="sd">    The prefence value ia a continuous, interpolated equivalent of the max_value_bin().</span>
<span class="sd">    For a cyclic distribution, this is the direction of the vector</span>
<span class="sd">    sum (see vector_sum()).</span>
<span class="sd">    For a non-cyclic distribution, this is the arithmetic average</span>
<span class="sd">    of the data on the bin_axis, where each bin is weighted by its</span>
<span class="sd">    value.</span>
<span class="sd">    Such a computation will generally produce much more precise maps using</span>
<span class="sd">    fewer test stimuli than the discrete method.  However, weighted_average</span>
<span class="sd">    methods generally require uniform and full-range sampling, which is not</span>
<span class="sd">    always feasible.</span>
<span class="sd">    For measurements at evenly-spaced intervals over the full range of</span>
<span class="sd">    possible parameter values, weighted_averages are a good measure of the</span>
<span class="sd">    underlying continuous-valued parameter preference, assuming that neurons</span>
<span class="sd">    are tuned broadly enough (and/or sampled finely enough) that they</span>
<span class="sd">    respond to at least two of the tested parameter values.  This method</span>
<span class="sd">    will not usually give good results when those criteria are not met, i.e.</span>
<span class="sd">    if the sampling is too sparse, not at evenly-spaced intervals, or does</span>
<span class="sd">    not cover the full range of possible values.  In such cases</span>
<span class="sd">    max_value_bin should be used, and the number of test patterns will</span>
<span class="sd">    usually need to be increased instead.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="n">p</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vector_sum</span><span class="p">(</span> <span class="n">d</span> <span class="p">)[</span><span class="mi">1</span><span class="p">]</span>  <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">cyclic</span>  <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_weighted_average</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="n">p</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>

        <span class="k">return</span> <span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span> <span class="p">)</span> <span class="p">}</span>


</div>
<div class="viewcode-block" id="DSF_TopTwoValues"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DSF_TopTwoValues">[docs]</a><span class="k">class</span> <span class="nc">DSF_TopTwoValues</span><span class="p">(</span> <span class="n">DescriptiveBimodalStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the two max values of distributions in the given matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="n">r</span>               <span class="o">=</span> <span class="p">{}</span>
        <span class="n">p</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">r</span><span class="p">[</span> <span class="s">&quot;&quot;</span> <span class="p">]</span>         <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span> <span class="p">)</span>
        <span class="n">p</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_max_value_bin</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="n">s</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="n">p</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">r</span><span class="p">[</span> <span class="s">&quot;Mode2&quot;</span> <span class="p">]</span>    <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">r</span>


</div>
<div class="viewcode-block" id="DSF_BimodalPeaks"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DSF_BimodalPeaks">[docs]</a><span class="k">class</span> <span class="nc">DSF_BimodalPeaks</span><span class="p">(</span> <span class="n">DescriptiveBimodalStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the two peak values of distributions in the given matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="n">r</span>               <span class="o">=</span> <span class="p">{}</span>
        <span class="n">p</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">d</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">r</span><span class="p">[</span> <span class="s">&quot;&quot;</span> <span class="p">]</span>         <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span> <span class="p">)</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">s</span>            <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">second_peak</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="n">p</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>               <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">r</span><span class="p">[</span> <span class="s">&quot;Mode2&quot;</span> <span class="p">]</span>    <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">r</span>


</div>
<div class="viewcode-block" id="VonMisesStatisticFn"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.VonMisesStatisticFn">[docs]</a><span class="k">class</span> <span class="nc">VonMisesStatisticFn</span><span class="p">(</span> <span class="n">DistributionStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for von Mises statistics</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># values to fit the maximum value of k parameter in von Mises distribution,</span>
    <span class="c"># as a function of the number of bins in the distribution. Useful for</span>
    <span class="c"># keeping selectivity in range 0..1. Values derived offline from distribution</span>
    <span class="c"># with a single active bin, and total bins from 8 to 32</span>
    <span class="n">vm_kappa_fit</span>    <span class="o">=</span> <span class="p">(</span> <span class="mf">0.206</span><span class="p">,</span> <span class="mf">0.614</span> <span class="p">)</span>

    <span class="c"># level of activity in units confoundable with noise. Used in von Mises fit,</span>
    <span class="c"># for two purposes: if the standard deviation of a distribution is below this</span>
    <span class="c"># value, the distribution is assumed to lack any mode; it is the maximum level</span>
    <span class="c"># of random noise added to a distribution before the fit optimization, for</span>
    <span class="c"># stability reasons</span>
    <span class="n">noise_level</span>     <span class="o">=</span> <span class="mf">0.001</span>

    <span class="c"># exit code of the distribution fit function. Codes are function-specific and</span>
    <span class="c"># each fit function, if provide exit codes, should have corresponding string translation</span>
    <span class="n">fit_exit_code</span>   <span class="o">=</span> <span class="mi">0</span>

    <span class="n">user_warned_if_unavailable</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="n">__abstract</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_orth</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">t</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the orthogonal orientation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">pi</span>


    <span class="k">def</span> <span class="nf">_in_pi</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">t</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce orientation from -pi..2pi to 0..pi</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">pi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">-</span> <span class="n">pi</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">pi</span>
        <span class="k">return</span> <span class="n">t</span>


<div class="viewcode-block" id="VonMisesStatisticFn.von_mises"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.VonMisesStatisticFn.von_mises">[docs]</a>    <span class="k">def</span> <span class="nf">von_mises</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a simplified von Mises function.</span>

<span class="sd">        Original formulation in Richard von Mises, &quot;Wahrscheinlichkeitsrechnung</span>
<span class="sd">        und ihre Anwendungen in der Statistik und theoretischen Physik&quot;, 1931,</span>
<span class="sd">        Deuticke, Leipzig; see also Mardia, K.V. and Jupp, P.E., &quot; Directional</span>
<span class="sd">        Statistics&quot;, 1999, J. Wiley, p.36;</span>
<span class="sd">        http://en.wikipedia.org/wiki/Von_Mises_distribution</span>
<span class="sd">        The two differences are that this function is a continuous probability</span>
<span class="sd">        distribution on a semi-circle, while von Mises is on the full circle,</span>
<span class="sd">        and that the normalization factor, which is the inverse of the modified</span>
<span class="sd">        Bessel function of first kind and 0 degree in the original, is here a fit parameter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">pars</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">exp</span><span class="p">(</span> <span class="n">k</span> <span class="o">*</span> <span class="p">(</span> <span class="n">cos</span><span class="p">(</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span> <span class="n">x</span> <span class="o">-</span> <span class="n">t</span> <span class="p">)</span> <span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</div>
<div class="viewcode-block" id="VonMisesStatisticFn.von2_mises"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.VonMisesStatisticFn.von2_mises">[docs]</a>    <span class="k">def</span> <span class="nf">von2_mises</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a simplified bimodal von Mises function</span>

<span class="sd">        Two superposed von Mises functions, with different peak and bandwith values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p1</span>  <span class="o">=</span> <span class="n">pars</span><span class="p">[</span> <span class="p">:</span> <span class="mi">3</span> <span class="p">]</span>
        <span class="n">p2</span>  <span class="o">=</span> <span class="n">pars</span><span class="p">[</span> <span class="mi">3</span> <span class="p">:</span> <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">von_mises</span><span class="p">(</span> <span class="n">p1</span><span class="p">,</span> <span class="n">x</span> <span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">von_mises</span><span class="p">(</span> <span class="n">p2</span><span class="p">,</span> <span class="n">x</span> <span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">von_mises_res</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">von_mises</span><span class="p">(</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">von2_mises_res</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">von2_mises</span><span class="p">(</span> <span class="n">pars</span><span class="p">,</span> <span class="n">x</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">norm_sel</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">n</span> <span class="p">):</span>
        <span class="n">m</span>   <span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">vm_kappa_fit</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="o">+</span> <span class="n">n</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vm_kappa_fit</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">log</span><span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">k</span> <span class="p">)</span> <span class="o">/</span> <span class="n">log</span><span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">m</span> <span class="p">)</span>

<div class="viewcode-block" id="VonMisesStatisticFn.fit_vm"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.VonMisesStatisticFn.fit_vm">[docs]</a>    <span class="k">def</span> <span class="nf">fit_vm</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        computes the best fit of the monovariate von Mises function in the</span>
<span class="sd">        semi-circle.</span>
<span class="sd">        Return a tuple with the orientation preference, in the same range of</span>
<span class="sd">        axis_bounds, the orientation selectivity, and an estimate of the</span>
<span class="sd">        goodness-of-fit, as the variance of the predicted orientation</span>
<span class="sd">        preference. The selectivity is given by the bandwith parameter of the</span>
<span class="sd">        von Mises function, modified for compatibility with other selectivity</span>
<span class="sd">        computations in this class. The bandwith parameter is transposed in</span>
<span class="sd">        logaritmic scale, and is normalized by the maximum value for the number</span>
<span class="sd">        of bins in the distribution, in order to give roughly 1.0 for a</span>
<span class="sd">        distribution with one bin at 1.0 an all the other at 0.0, and 0.0 for</span>
<span class="sd">        uniform distributions. The normalizing factor of the selectivity is fit</span>
<span class="sd">        for the total number of bins, using fit parameters computed offline.</span>
<span class="sd">        There are conditions that prevents apriori the possibility to fit the</span>
<span class="sd">        distribution:</span>
<span class="sd">            * not enough bins, at least 4 are necessary</span>
<span class="sd">            * the distribution is too flat, below the noise level</span>
<span class="sd">        and conditions of aposteriori failures:</span>
<span class="sd">            * &quot;ier&quot; flag returned by leastsq out of ( 1, 2, 3, 4 )</span>
<span class="sd">            * no estimated Jacobian around the solution</span>
<span class="sd">            * negative bandwith (the peak of the distribution is convex)</span>
<span class="sd">        Note that these are the minimal conditions, their fulfillment does not</span>
<span class="sd">        warrant unimodality, is up to the user to check the goodness-of-fit value</span>
<span class="sd">        for an accurate acceptance of the fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unavailable_scipy_optimize</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">VonMisesStatisticFn</span><span class="o">.</span><span class="n">user_warned_if_unavailable</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;scipy.optimize not available, dummy von Mises fit&quot;</span><span class="p">)</span>
                <span class="n">VonMisesStatisticFn</span><span class="o">.</span><span class="n">user_warned_if_unavailable</span><span class="o">=</span><span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">3</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">to_pi</span>   <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">axis_range</span>
        <span class="n">x</span>       <span class="o">=</span> <span class="n">to_pi</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">distribution</span><span class="o">.</span><span class="n">bins</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">n</span>       <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span> <span class="s">&quot;no von Mises fit possible with less than 4 bins&quot;</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">y</span>   <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">distribution</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_level</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">rn</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_level</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
        <span class="n">p0</span>  <span class="o">=</span> <span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">distribution</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">r</span>   <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">von_mises_res</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rn</span> <span class="p">),</span> <span class="n">full_output</span> <span class="o">=</span> <span class="bp">True</span> <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">[</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="ow">in</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">residuals</span>   <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">2</span> <span class="p">][</span> <span class="s">&#39;fvec&#39;</span> <span class="p">]</span>
        <span class="n">jacobian</span>    <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span>
        <span class="n">bandwith</span>    <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">0</span> <span class="p">][</span> <span class="mi">1</span> <span class="p">]</span>
        <span class="n">tuning</span>      <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">0</span> <span class="p">][</span> <span class="mi">2</span> <span class="p">]</span>

        <span class="k">if</span> <span class="n">bandwith</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">jacobian</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

        <span class="n">error</span>       <span class="o">=</span> <span class="p">(</span> <span class="n">residuals</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">p0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">covariance</span>  <span class="o">=</span> <span class="n">jacobian</span> <span class="o">*</span> <span class="n">error</span>
        <span class="n">g</span>   <span class="o">=</span> <span class="n">covariance</span><span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">]</span>
        <span class="n">p</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_pi</span><span class="p">(</span> <span class="n">tuning</span> <span class="p">)</span> <span class="o">/</span> <span class="n">to_pi</span>
        <span class="n">s</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_sel</span><span class="p">(</span> <span class="n">bandwith</span><span class="p">,</span> <span class="n">n</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span>
</div>
    <span class="k">def</span> <span class="nf">vm_fit_exit_codes</span> <span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;succesfull exit&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;not enough bins for this fit&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;flat distribution&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;flat distribution&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;missing scipy.optimize import&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;unknown exit code&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;error &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">-</span> <span class="mi">100</span> <span class="p">)</span> <span class="o">+</span> <span class="s">&quot; in scipy.optimize.leastsq&quot;</span>

        <span class="k">return</span> <span class="s">&quot;unknown exit code&quot;</span>


<div class="viewcode-block" id="VonMisesStatisticFn.fit_v2m"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.VonMisesStatisticFn.fit_v2m">[docs]</a>    <span class="k">def</span> <span class="nf">fit_v2m</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        computes the best fit of the bivariate von Mises function in the</span>
<span class="sd">        semi-circle.</span>
<span class="sd">        Return the tuple:</span>
<span class="sd">        (</span>
<span class="sd">            orientation1_preference, orientation1_selectivity, goodness_of_fit1,</span>
<span class="sd">            orientation2_preference, orientation2_selectivity, goodness_of_fit2</span>
<span class="sd">        )</span>
<span class="sd">        See fit_vm() for considerations about selectivity and goodness_of_fit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">null</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">unavailable_scipy_optimize</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">VonMisesStatisticFn</span><span class="o">.</span><span class="n">user_warned_if_unavailable</span><span class="p">:</span>
                <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s">&quot;scipy.optimize not available, dummy von Mises fit&quot;</span><span class="p">)</span>
                <span class="n">VonMisesStatisticFn</span><span class="o">.</span><span class="n">user_warned_if_unavailable</span><span class="o">=</span><span class="bp">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">3</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="n">to_pi</span>   <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">axis_range</span>
        <span class="n">x</span>       <span class="o">=</span> <span class="n">to_pi</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">distribution</span><span class="o">.</span><span class="n">bins</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">n</span>       <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">param</span><span class="o">.</span><span class="n">Parameterized</span><span class="p">()</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span> <span class="s">&quot;no bimodal von Mises fit possible with less than 8 bins&quot;</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="n">y</span>       <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">distribution</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_level</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="n">rn</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_level</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="p">)</span>
        <span class="n">t0</span>  <span class="o">=</span> <span class="n">distribution</span><span class="o">.</span><span class="n">max_value_bin</span><span class="p">()</span>
        <span class="n">p0</span>  <span class="o">=</span> <span class="p">(</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orth</span><span class="p">(</span> <span class="n">t0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">r</span>   <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">von2_mises_res</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">rn</span> <span class="p">),</span> <span class="n">full_output</span> <span class="o">=</span> <span class="bp">True</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="p">[</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="ow">in</span> <span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">100</span> <span class="o">+</span> <span class="n">r</span><span class="p">[</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="n">residuals</span>   <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">2</span> <span class="p">][</span> <span class="s">&#39;fvec&#39;</span> <span class="p">]</span>
        <span class="n">jacobian</span>    <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span>
        <span class="n">bandwith_1</span>  <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">0</span> <span class="p">][</span> <span class="mi">1</span> <span class="p">]</span>
        <span class="n">tuning_1</span>    <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">0</span> <span class="p">][</span> <span class="mi">2</span> <span class="p">]</span>
        <span class="n">bandwith_2</span>  <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">0</span> <span class="p">][</span> <span class="mi">4</span> <span class="p">]</span>
        <span class="n">tuning_2</span>    <span class="o">=</span> <span class="n">r</span><span class="p">[</span> <span class="mi">0</span> <span class="p">][</span> <span class="mi">5</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">jacobian</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">2</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">if</span> <span class="n">bandwith_1</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">null</span>
        <span class="k">if</span> <span class="n">bandwith_2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">null</span>

        <span class="n">error</span>       <span class="o">=</span> <span class="p">(</span> <span class="n">residuals</span> <span class="o">**</span> <span class="mi">2</span> <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span> <span class="n">n</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span> <span class="n">p0</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">covariance</span>  <span class="o">=</span> <span class="n">jacobian</span> <span class="o">*</span> <span class="n">error</span>
        <span class="n">g1</span>  <span class="o">=</span> <span class="n">covariance</span><span class="p">[</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="p">]</span>
        <span class="n">g2</span>  <span class="o">=</span> <span class="n">covariance</span><span class="p">[</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span> <span class="p">]</span>
        <span class="n">p1</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_pi</span><span class="p">(</span> <span class="n">tuning_1</span> <span class="p">)</span> <span class="o">/</span> <span class="n">to_pi</span>
        <span class="n">p2</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_pi</span><span class="p">(</span> <span class="n">tuning_2</span> <span class="p">)</span> <span class="o">/</span> <span class="n">to_pi</span>
        <span class="n">s1</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_sel</span><span class="p">(</span> <span class="n">bandwith_1</span><span class="p">,</span> <span class="n">n</span> <span class="p">)</span>
        <span class="n">s2</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm_sel</span><span class="p">(</span> <span class="n">bandwith_2</span><span class="p">,</span> <span class="n">n</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span>  <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">p1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">g2</span>
</div>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">distribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply the distribution statistic function; must be implemented by subclasses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>


</div>
<div class="viewcode-block" id="DSF_VonMisesFit"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DSF_VonMisesFit">[docs]</a><span class="k">class</span> <span class="nc">DSF_VonMisesFit</span><span class="p">(</span> <span class="n">VonMisesStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the main mode of distribution in the given matrix, by fit with von Mises function</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">worst_fit</span>   <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span> <span class="n">softbounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">            worst good-of-fitness value for accepting the distribution as monomodal&quot;&quot;&quot;</span> <span class="p">)</span>

    <span class="c"># default result in case of failure of the fit</span>
    <span class="n">null_result</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">:</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">goodness_of_fit</span><span class="o">=</span><span class="mi">0</span> <span class="p">),</span> <span class="s">&quot;Modes&quot;</span><span class="p">:</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">number</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span> <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span> <span class="p">):</span>
        <span class="n">f</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_vm</span><span class="p">(</span> <span class="n">distribution</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">f</span><span class="p">[</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">worst_fit</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_result</span>
        <span class="n">results</span>             <span class="o">=</span> <span class="p">{}</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span>             <span class="o">=</span> <span class="n">f</span>
        <span class="n">p</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">results</span><span class="p">[</span> <span class="s">&quot;&quot;</span> <span class="p">]</span>       <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">goodness_of_fit</span><span class="o">=</span><span class="n">g</span> <span class="p">)</span>
        <span class="n">results</span><span class="p">[</span> <span class="s">&quot;Modes&quot;</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">number</span><span class="o">=</span><span class="mi">1</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>

</div>
<div class="viewcode-block" id="DSF_BimodalVonMisesFit"><a class="viewcode-back" href="../../../Reference_Manual/topo.misc.distribution-module.html#topo.misc.distribution.DSF_BimodalVonMisesFit">[docs]</a><span class="k">class</span> <span class="nc">DSF_BimodalVonMisesFit</span><span class="p">(</span> <span class="n">VonMisesStatisticFn</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the two modes of distributions in the given matrix, by fit with von Mises function</span>

<span class="sd">    The results of the main mode are available in</span>
<span class="sd">    self.{preference,selectivity,good_of_fit}, while the second mode results are</span>
<span class="sd">    in the first element of the self.more_modes list, as a dictionary with keys</span>
<span class="sd">    preference,selectivity,good_of_fit.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">worst_fit</span>   <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">Number</span><span class="p">(</span> <span class="n">default</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span> <span class="n">softbounds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">            worst good-of-fitness value for accepting the distribution as mono- or bi-modal&quot;&quot;&quot;</span> <span class="p">)</span>

    <span class="c"># default result in case of failure of the fit</span>
    <span class="n">null_result</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&quot;&quot;</span><span class="p">:</span>         <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">goodness_of_fit</span><span class="o">=</span><span class="mi">0</span> <span class="p">),</span>
        <span class="s">&quot;Mode2&quot;</span><span class="p">:</span>    <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">goodness_of_fit</span><span class="o">=</span><span class="mi">0</span> <span class="p">),</span>
        <span class="s">&quot;Modes&quot;</span><span class="p">:</span>    <span class="n">Pref</span><span class="p">(</span> <span class="n">number</span><span class="o">=</span><span class="mi">0</span> <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">_analyze_distr</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">d</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Analyze the given distribution with von Mises bimodal fit.</span>

<span class="sd">        The distribution is analyzed with both unimodal and bimodal fits, and a</span>
<span class="sd">        decision about the number of modes is made by comparing the goodness of</span>
<span class="sd">        fit. It is a quick but inaccurate way of estimating the number of modes.</span>
<span class="sd">        Return preference, selectivity, goodness of fit for both modes, and the</span>
<span class="sd">        estimated numer of modes, None if even the unimodal fit failed. If the</span>
<span class="sd">        distribution is unimodal, values of the second mode are set to 0. The main</span>
<span class="sd">        mode is always the one with the largest selectivity (von Mises bandwith).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no1</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">f</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_vm</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">no1</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span>
        <span class="n">f2</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_v2m</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_exit_code</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">f2</span><span class="p">[</span> <span class="mi">2</span> <span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">worst_fit</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">no1</span> <span class="ow">or</span> <span class="n">f</span><span class="p">[</span> <span class="o">-</span><span class="mi">1</span> <span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">worst_fit</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
        <span class="n">p1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">g2</span>  <span class="o">=</span> <span class="n">f2</span>
        <span class="k">if</span> <span class="n">g1</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">s2</span> <span class="o">&gt;</span> <span class="n">s1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p2</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">p1</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="mi">2</span>


    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">distribution</span> <span class="p">):</span>
        <span class="n">f</span>   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_analyze_distr</span><span class="p">(</span> <span class="n">distribution</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">f</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">null_result</span>

        <span class="n">results</span>             <span class="o">=</span> <span class="p">{}</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span>             <span class="o">=</span> <span class="n">f</span><span class="p">[</span> <span class="p">:</span> <span class="mi">3</span> <span class="p">]</span>
        <span class="n">p</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">results</span><span class="p">[</span> <span class="s">&quot;&quot;</span> <span class="p">]</span>       <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">goodness_of_fit</span><span class="o">=</span><span class="n">g</span> <span class="p">)</span>
        <span class="n">p</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">n</span>          <span class="o">=</span> <span class="n">f</span><span class="p">[</span> <span class="mi">3</span> <span class="p">:</span> <span class="p">]</span>
        <span class="n">p</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">p</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">value_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">s</span>                   <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="o">*</span> <span class="p">(</span> <span class="n">s</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">selectivity_scale</span><span class="p">[</span> <span class="mi">0</span> <span class="p">]</span> <span class="p">)</span>
        <span class="n">results</span><span class="p">[</span> <span class="s">&quot;Mode2&quot;</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">preference</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">selectivity</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">goodness_of_fit</span><span class="o">=</span><span class="n">g</span> <span class="p">)</span>
        <span class="n">results</span><span class="p">[</span> <span class="s">&quot;Modes&quot;</span> <span class="p">]</span>  <span class="o">=</span> <span class="n">Pref</span><span class="p">(</span> <span class="n">number</span><span class="o">=</span><span class="n">n</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</pre></div></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/topo-banner7.png" alt="Logo"/>
            </a></p>
<ul class="global-toc">
<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../News/index.html">News</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>
<li><a href="../../../Reference_Manual/index.html">Reference Manual</a></li>
<li><a href="../../../Developer_Manual/index.html">Developer Manual</a></li>
<li><a href="../../../Forums/index.html">Forums</a></li>
<li><a href="../../../Team_Members/index.html">Team Members</a></li>
<li><a href="../../../Future_Work/index.html">Future Work</a></li>
<li><a href="../../../FAQ/index.html">FAQ</a></li>
<li><a href="../../../Links/index.html">Links</a></li>
<li><a href="../../../Home/pubs.html">Publications</a></li>
</ul>
<h3><a href="../../../index.html">Table Of Contents</a></h3>


<h3>This Page</h3>
<ul class="this-page-menu">
	<li><a	href="https://github.com/ioam/topographica/edit/master/doc/_modules/topo/misc/distribution.rst" rel="nofollow">Edit on GitHub</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
<li><a href="../../../index.html">Home</a></li>
<li><a href="../../../Downloads/index.html">Downloads</a></li>
<li><a href="../../../Tutorials/index.html">Tutorials</a></li>
<li><a href="../../../User_Manual/index.html">User Manual</a></li>


<li><ul class="parents">



          <li><a href="../../index.html" >Module code</a> &raquo;</li>

</ul></li>


      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, IOAM.
      Last updated on Nov 04, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>